pixel_f ray_color(const ray& r, hittable_list& worldList){
    //initialize hit record
    hit_record hitRecord;
    interval i(0.001f, infinity);
    if (worldList.hit(r, i, hitRecord)){
        auto view_direction = -r.direction();
        auto dot_product = dot(hitRecord.normal, view_direction);
        interval c_interval(0.0, 1.0);
        auto clamped_dot = float(c_interval.clamp(dot_product));z
        return {clamped_dot, clamped_dot, clamped_dot};
    }

    auto unit_vec = 0.5f * (unit(r.direction()).y + 1.0f);
    return lerp_color(unit_vec, pixel_f{0.0,0.0,0.0}, pixel_f{0.5, 0.7, 1.0});
}

// old render without antialiasing
void render(const string& fname, hittable_list& world, const vec3f& ep = {0,0,0}, const float& fl = 1.0){
    initialize(ep, fl);

    ofstream out;
    out.open(fname);
    // ppm header
    out << "P3\n" << image_width << " " << image_height << "\n255\n" <<endl;
    // ppm body render
    for (int i = 0; i < image_height; i++){
        clog << "\rScanlines remaining: " << i << "/" << image_height << flush;
        for (int j = 0; j < image_width; j++){
            // color sampling without antialiasing
            auto d = pixel_center(i, j) - eye_point;
            auto r = ray(eye_point, d);
            auto mean_color = ray_color(r, world);
            auto p_i = convert_pixel_i(mean_color); // clamps colors and converts into integers
            out << p_i << " ";
        }
        out << endl;
    }
    out.close();
    clog << "\r< -------------- Done -------------- >\n" << flush;
}