pixel_f ray_color(const ray& r, hittable_list& worldList){
    //initialize hit record
    hit_record hitRecord;
    interval i(0.001f, infinity);
    if (worldList.hit(r, i, hitRecord)){
        auto view_direction = -r.direction();
        auto dot_product = dot(hitRecord.normal, view_direction);
        interval c_interval(0.0, 1.0);
        auto clamped_dot = float(c_interval.clamp(dot_product));
        return {clamped_dot, clamped_dot, clamped_dot};
    }

    auto unit_vec = 0.5f * (unit(r.direction()).y + 1.0f);
    return lerp_color(unit_vec, pixel_f{0.0,0.0,0.0}, pixel_f{0.5, 0.7, 1.0});
}

// old render without antialiasing
void render(const string& fname, hittable_list& world, const vec3f& ep = {0,0,0}, const float& fl = 1.0){
    initialize(ep, fl);

    ofstream out;
    out.open(fname);
    // ppm header
    out << "P3\n" << image_width << " " << image_height << "\n255\n" <<endl;
    // ppm body render
    for (int i = 0; i < image_height; i++){
        clog << "\rScanlines remaining: " << i << "/" << image_height << flush;
        for (int j = 0; j < image_width; j++){
            // color sampling without antialiasing
            auto d = pixel_center(i, j) - eye_point;
            auto r = ray(eye_point, d);
            auto mean_color = ray_color(r, world);
            auto p_i = convert_pixel_i(mean_color); // clamps colors and converts into integers
            out << p_i << " ";
        }
        out << endl;
    }
    out.close();
    clog << "\r< -------------- Done -------------- >\n" << flush;
}

// old ray_color definition before material implementation 3/08/24
pixel_f ray_color(const ray& r, hittable_list& worldList, const int& recursive_depth){
    if (recursive_depth <= 0){ // end of recursion check
        return {0,0,0};
    }

    hit_record hitRecord; // initialize hit record
    interval i(0.01f, infinity);    // clamp rays too close to surface of object
    if (worldList.hit(r, i, hitRecord)){
        // Simple diffuse material
//                auto direction = random_on_hemisphere(hitRecord.normal);
        // lambertian distribution
        auto direction = hitRecord.normal + random_unit_vector();
        auto r_on_sphere = ray(hitRecord.position, direction);
        return 0.7 * ray_color(r_on_sphere, worldList, recursive_depth-1);
    }

    auto unit_vec = unit(r.direction()).y;
    return lerp_color(unit_vec, pixel_f{1.0,1.0,1.0}, pixel_f{0.5, 0.7, 1.0});
}

inline vec3 random_in_unit_disk() {
    while (true) {
        auto p = vec3f(random_float(-1,1), random_float(-1,1), 0);
        if (p.sqr_length() < 1)
            return p;
    }
}

PLY MANUAL

for (const auto& element : data) {
	for (const auto& prop : element.data->properties) {

element.key: vertex | element.data->size(): 3502
    prop.key: x | prop.data->type.name(): f | prop.data->size(): 3502
    - y -- type: f -- size: 3502
    - z -- type: f -- size: 3502
    - nx -- type: f -- size: 3502
    - ny -- type: f -- size: 3502
    - nz -- type: f -- size: 3502
    - red -- type: h -- size: 3502
    - green -- type: h -- size: 3502
    - blue -- type: h -- size: 3502
    - alpha -- type: h -- size: 3502
* face -- size: 7000
    - vertex_indices -- type: list of i -- size: 21000
---------------------------------------------------------------------------

x value of the first vertex element:
data["vertex"]->properties["x"]->at<float>(0): -0.030394

Coordinates of the 5 first vertices (out of 3502):
// one way of accessing values:
data["vertex"]->properties["x"]->ptr<float>(): -0.030394
data["vertex"]->properties["y"]->ptr<float>(): 0.064757
data["vertex"]->properties["z"]->ptr<float>(): 0.01881

* -0.032484 0.062235 0.020179
* -0.031546 0.063672 0.021553
* -0.030159 0.063779 0.017815
* -0.031724 0.061122 0.018518
---------------------------------------------------------------------------

Same output of the 5 first vertices:
// another way:
typedef std::vector<std::array<float, 3 > > Cloud   // define type Cloud
Cloud points;
Cloud normals;
toPointCloud<float, Cloud>(data, points);           // populate clouds
toNormalCloud<float, Cloud>(data, normals);
// access with for loop
for (size_t i = 0; i < 5; ++i) {
    points[i][0] : -0.030394
    points[i][1] : 0.064757
    points[i][2] : 0.01881
}

* -0.032484 0.062235 0.020179
* -0.031546 0.063672 0.021553
* -0.030159 0.063779 0.017815
* -0.031724 0.061122 0.018518
---------------------------------------------------------------------------

RGBA colour of the 5 first vertices:
// to access color use the same method then before, using Cloud type
typedef std::vector<std::array<unsigned char, 4> > RGBACloud; // define type color cloud
RGBACloud rgbaCloud;
std::vector<plycpp::PropertyArrayConstPtr> properties {     // define properties fields
    data["vertex"]->properties["red"],
    data["vertex"]->properties["green"],
    data["vertex"]->properties["blue"],
    data["vertex"]->properties["alpha"]
}
plycpp::packProperties<unsigned char, RGBACloud>(properties, rgbaCloud); // populate cloud
// access with for loop
for (size_t i = 0; i < 5; ++i) {
    static_cast<unsigned int>(rgbaCloud[i][0]) : 254
    static_cast<unsigned int>(rgbaCloud[i][1]) : 254
    static_cast<unsigned int>(rgbaCloud[i][2]) : 254
    static_cast<unsigned int>(rgbaCloud[i][3]) : 255
}

* 253 253 253 255
* 253 253 253 255
* 245 245 245 255
* 236 236 236 255
---------------------------------------------------------------------------

Vertex indices of the first triangle:
* 0 1 2

Point cloud exported to point_cloud_ascii.ply
Point cloud exported to point_cloud_binary.ply
Enter a char to exit...